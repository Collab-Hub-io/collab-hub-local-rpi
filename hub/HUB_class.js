"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CHMessageType=exports.CHMode=void 0;const _=require("lodash"),https=require("https");var CHMode,CHMessageType;!function(e){e.PUSH="push",e.PUBLISH="publish"}(CHMode||(exports.CHMode=CHMode={})),function(e){e.CONTROL="control",e.EVENT="event",e.MESSAGE="message",e.ROOMS="room",e.SELF="self",e.CHAT="chat",e.LIST="list",e.FROMSERVER="fromserver",e.ERROR="error"}(CHMessageType||(exports.CHMessageType=CHMessageType={}));class HUB{constructor(e){this.modeHandler=(e,t)=>{for(const t of this.enumKeys(CHMode))if(e.toLowerCase()===CHMode[t])return CHMode[t];return null!=t?t:CHMode.PUSH},this.boolHandler=e=>{if("string"==typeof e){return"true"===e.toLowerCase()}return e},this.log=e=>{!0===this.consoleDisplay&&console.log(`${e}`)},this.options=e||{io:null,consoleDisplay:!0,verboseServerMessage:!0,name:"default"},this.IO=e.io,this.consoleDisplay=!1,this.Version=e.version||"0.3.3",this.verboseServerMessage=!0,this.Users=new Map,this.Controls=[],this.Events=[],this.Rooms=[],this.Name=e.name,this.log("Created HUB instance with name: "+this.Name),this.statusURL="https://collab-hub-io.github.io/server-status/update.json"}onNewConnection(e){(()=>{https.get(this.statusURL,e=>{let t="";e.on("data",e=>{t+=e}),e.on("end",()=>{try{const e=JSON.parse(t),o=[];for(const t in e)e.hasOwnProperty(t)&&o.push([`${t}: ${e[t]}`]);console.dir(o);for(let e=o.length-1;e>-1;e--){const t=o[e];d(t.toString())}}catch(e){console.error(e.message)}})}).on("error",e=>{console.error(e.message)})})();const t=e.nsp.name;e.handshake.query.username&&this.log("Connection has incoming query properties "+e.handshake.query.username),e.on("connect_error",e=>{console.log(`Connect_error due to ${e.message}`)}),e.on("ping",()=>{console.log("ping")}),e.emit("ping"),e.on("pong",()=>{console.log("pong")}),e.on("clearUsers",()=>{e.broadcast.emit("serverMessage","clearing user list"),this.IO.emit("serverMessage","clearing user list"),this.log("Clearing user list..."),L(),F()}),e.on("chat",e=>{a(e)}),e.on("addUsername",e=>{c(e)}),e.on("event",e=>{n(e)}),e.on("getEvents",()=>{j()}),e.on("clearControl",e=>{x(e)}),e.on("clearAllControls",()=>{x()}),e.on("clearEvent",e=>{T(e)}),e.on("clearAllEvents",()=>{T()}),e.on("getUsers",()=>{F()}),e.on("clearUsers",()=>{L()}),e.on("disconnect",e=>{console.log("Disconnect Reason: "+e),B()}),e.on("control",e=>{i(e)}),e.on("observeControl",e=>{b(e,w)}),e.on("unobserveControl",e=>{y(e)}),e.on("unpublishControl",e=>{E(e)}),e.on("observeAllControl",e=>{f(e)}),e.on("observeEvent",e=>{C(e,A)}),e.on("unobserveEvent",e=>{k(e)}),e.on("unpublishEvent",e=>{H(e)}),e.on("getMyInfo",()=>{g()}),e.on("getMyControls",()=>{$(),R(),w()}),e.on("getMyEvents",()=>{O(),I(),A()}),e.on("observeAllEvents",e=>{p(e)}),e.on("getControl",e=>{r(e)}),e.on("setConsoleDisplay",e=>{G(e)}),e.on("allRooms",()=>{Q()}),e.on("myRooms",()=>{W()}),e.on("joinRoom",e=>{o(e)}),e.on("leaveRoom",e=>{s(e)});const o=t=>{if(null==t||"object"!=typeof t){const e="joinRoom payload must be an object.";return this.log(`joinRoom payload is not an object: ${String(t)}`),oe(e),void d(e)}const o=t;if(!Object.prototype.hasOwnProperty.call(o,"room")){const e="joinRoom missing 'room' property.";return this.log(`${N()} attempted to join room with no 'room' property.`),oe(e),void d(e)}if(null==o.room){const e=`No room param- ${o.room}`;return this.log(`Error: ${e}`),oe(e),void d(e)}const s=String(o.room).trim();if(""===s){const e="joinRoom room parameter was empty/blank.";return this.log(e),oe(e),void d(e)}this.Rooms.includes(s)||(this.Rooms.push(s),this.log(`Created new room: ${s}`));try{e.join(s)}catch(e){const t=`Error joining room '${s}'.`;return this.log(`${t} Details: ${(null==e?void 0:e.message)||e}`),oe(t),void d(t)}d(`${e.id} socket has joined ${s}`),console.log(`${e.id} socket has joined ${s}`),te(),I(),R(),Z()},s=o=>{if(null==o||"object"!=typeof o){const e="leaveRoom payload must be an object.";return this.log(`leaveRoom payload is not an object: ${String(o)}`),oe(e),void d(e)}const s=o;if(!Object.prototype.hasOwnProperty.call(s,"room")){const e="leaveRoom missing 'room' property.";return this.log(`${N()} attempting to leave room with no 'room' property.`),oe(e),void d(e)}const r=String(s.room).trim();if(""===r){const e="leaveRoom room parameter was empty/blank.";return this.log(e),oe(e),void d(e)}this.log(`leave room ${r}, ${t}`);const n=this.IO.of(t).adapter.rooms;if("function"==typeof n.has?n.has(r):!!n[r]){try{e.leave(r)}catch(e){const t=`Error leaving room '${r}'.`;return this.log(`${t} Details: ${(null==e?void 0:e.message)||e}`),oe(t),void d(t)}d("You have left room "+r),W(e.id),Q(),this.Users.forEach(e=>{Z(e.id),I(e.id),R(e.id),Z(e.id),ee(e.id),X(e.id)})}else{const e=`Attempting to leave room that doesn't exist - ${r}`;this.log(e),oe(e),d(e)}return this},r=t=>{if(null==t||"object"!=typeof t)return this.log(`getControl payload is not an object: ${String(t)}`),void oe("getControl payload must be an object.");const o=t;if(!Object.prototype.hasOwnProperty.call(o,"header"))return this.log("getControl missing header parameter"),void oe("getControl missing header parameter: { header: <headername> }");if("dump"===o.header)return void U();const s=K(o.header);if(!s){const e=`getControl: no such control '${o.header}'.`;return this.log(e),void oe(e)}const r={header:s.header,values:s.values};e.emit("control",r)},n=o=>{if(null==o||"object"!=typeof o)return this.log(`Event payload is not an object: ${String(o)}`),void oe("Event payload must be an object.");const s=o;if(!Object.prototype.hasOwnProperty.call(s,"header"))return this.log("Event missing 'header' property."),void oe("Event missing 'header' property.");if(this.log(`received event: ${s.header}`),Object.prototype.hasOwnProperty.call(s,"mode")&&null!=s.mode||(s.mode="push"),s.mode=this.modeHandler(s.mode),null!=s.target&&"string"!=typeof s.target)return this.log("Event 'target' must be a string if provided."),void oe("Event 'target' must be a string.");if(s.mode===CHMode.PUBLISH){let o=this.Events.find(e=>e.header===s.header);if(null==o){this.log(`adding Event...${s.header}`);const t={header:s.header,from:e.id,observers:[],mode:s.mode,target:s.target};this.Events.push(t),o=this.Events.find(e=>e.header===s.header),u("myEvents",s.header),j(),S(),o=this.Events.find(e=>e.header===s.header)}else{if(o.from!==e.id)return this.log(`Comparing ${o.from} with socket: ${e.id} `),this.log(`Rejecting Control: Header '${o.header} already being used by ${N(o.from)}.`),void oe(`Rejecting Control: Header '${o.header} already being used by ${N(o.from)}.`);o.mode!==s.mode&&("publish"!==s.mode&&S(),j());const r={header:s.header,from:N()};this.log(`A Publish Event Received:  ${s.header} : ${s.target}`),o.observers.length>0&&l(CHMessageType.EVENT,o.observers,r);let n=Array.from(this.Users.values()).filter(e=>!0===e.observeallevents).map(e=>e.id).filter(e=>!o.observers.includes(e));const i=h();if("all"===s.target);else if(this.IO.of(t).adapter.rooms.has(s.target)){const e=Array.from(this.IO.of(t).adapter.rooms.get(s.target));n=n.filter(t=>e.includes(t))}else i.includes(P(s.target))&&(n=n.filter(e=>e===s.target));if(this.log("Targeted Observers: "+n),n.length>0)return void l(CHMessageType.EVENT,n,r)}}if(s.mode===CHMode.PUSH){const e={header:s.header,from:N()};if("all"===s.target){const t=h();return void l(CHMessageType.EVENT,t,e)}if(this.Rooms.includes(s.target))return this.log(`Sending Event ${s.header} to Room  ${s.target}`),void this.IO.of(t).to(s.target).emit("event",e);const o=P(s.target);null!==o&&(this.log(`Sending event ${s.header} to target user ${o}`),l(CHMessageType.EVENT,o,e))}},i=o=>{if(null==o||"object"!=typeof o)return this.log(`Control payload is not an object: ${String(o)}`),void oe("Control payload must be an object.");const s=o,r=new Object(s);if(this.isCHControlToServer(r)||(this.log(`Control object missing 'target'; defaulting target to 'all'. Payload: ${JSON.stringify(s)}`),s.target="all"),null==s.header)return this.log(`Control data without header. Sender: ${N(e.id)} - ${e.id}`),void oe("Control message missing 'header'.");if(null==s.mode)return this.log(`Control data without mode: ${N(e.id)} - ${e.id}`),void oe("Control message missing 'mode'.");if(s.mode=this.modeHandler(s.mode),null==s.target)s.target="all";else if("string"!=typeof s.target)return this.log(`Control 'target' must be a string if provided: ${JSON.stringify(s)}`),void oe("Control 'target' must be a string if provided.");if(this.log("control: "+s.header+" - "+s.values+" mode: "+s.mode),s.mode===CHMode.PUBLISH){let o=this.Controls.find(e=>e.header===s.header);if(null==o){this.log(`Adding new Control... ${s} : sid ${e.id}`);const t={header:s.header,values:s.values,from:e.id,observers:[],mode:s.mode,target:s.target};this.Controls.push(t),u("myControls",s.header),U(),M(),o=this.Controls.find(e=>e.header===s.header)}else{if(o.from!==e.id)return this.log(`Comparing ${o.from} with socket: ${e.id}`),this.log(`Rejecting Control: Header '${o.header} already being used by ${N(o.from)}.`),void oe(`Rejecting Control: Header '${o.header} already being used by ${N(o.from)}.`);o.mode!==s.mode&&("publish"!==s.mode&&M(),U()),o.values=s.values,o.from=e.id,o.mode=s.mode}const r={header:s.header,values:s.values,from:N(e.id)};o.observers.length>0&&l(CHMessageType.CONTROL,o.observers,r);let n=Array.from(this.Users.values()).filter(e=>!0===e.observeallcontrol).map(e=>e.id).filter(e=>!o.observers.includes(e));const i=h();if("all"===s.target);else if(this.IO.of(t).adapter.rooms.get(s.target)){const e=Array.from(this.IO.of(t).adapter.rooms.get(s.target));n=n.filter(t=>e.includes(t))}else i.includes(P(s.target))&&(n=n.filter(e=>e===s.target));n.length>0&&l(CHMessageType.CONTROL,n,r),this.log("Targeted Observers: "+n),this.log("New Public Control Data: "+s.header+" - "+s.values+" - from: "+N())}if(s.mode===CHMode.PUSH){const o={header:s.header,values:s.values,from:N(e.id)};if("all"===s.target){const e=h();l(CHMessageType.CONTROL,e,o)}if(this.Rooms.includes(s.target))return this.log("Control data to room: "+s.target),void this.IO.of(t).to(s.target).emit("control",o);const r=P(s.target);null!==r&&(this.log("sending control to user"),l(CHMessageType.CONTROL,r,o))}},a=o=>{var s;if(null==o||"object"!=typeof o)return this.log(`Chat payload is not an object: ${String(o)}`),void oe("Chat payload must be an object.");const r=o;if(!Object.prototype.hasOwnProperty.call(r,"chat"))return this.log(`Chat message missing 'chat' property: ${JSON.stringify(r)}`),void oe("Chat message missing 'chat' property.");if(!Object.prototype.hasOwnProperty.call(r,"target"))return this.log(`Chat message missing 'target' property: ${JSON.stringify(r)}`),void oe("Chat message missing 'target' property.");if("string"!=typeof r.chat)return this.log(`Chat 'chat' must be a string: ${JSON.stringify(r)}`),void oe("Chat 'chat' must be a string.");let n=r.target;if(null==n&&(n="all"),"string"!=typeof n)return this.log(`Chat 'target' must be a string: ${JSON.stringify(r)}`),void oe("Chat 'target' must be a string.");n=n.toLowerCase(),r.target=n;const i={id:null!==(s=N())&&void 0!==s?s:e.id,chat:r.chat};if("all"===n)return this.IO.of(t).emit("chat",i),void this.log("chatting all: "+r.chat);if(this.Rooms.includes(n))return this.log("chatting to room: "+n),void this.IO.of(t).to(n).emit("chat",i);const a=P(n);null!==a?(this.log(`chatting to user:  ${i.chat} + ${n}: ${a}`),l(CHMessageType.CHAT,a,i)):d("Chat with a username target did not work -- please check username construction.")},l=(t,o,s)=>{switch(t){case CHMessageType.CONTROL:if(Array.isArray(o))for(const r of o)e.to(r).emit(t,s);else e.to(o).emit(t,s);break;case CHMessageType.EVENT:if(Array.isArray(o))for(const r of o)e.to(r).emit(t,s),this.log(`emitting ${t} to ${r}`);else e.to(o).emit(t,s),this.log(`emitting ${t} to ${o}`);break;case CHMessageType.CHAT:if("string"==typeof o)return void e.to(o).emit(t,s);for(const r of o)e.to(r).emit(t,s),!0===this.consoleDisplay&&this.log(`emitting ${t} to ${r}`);break;case CHMessageType.MESSAGE:if(Array.isArray(o)){!0===this.consoleDisplay&&this.log(`${Array.isArray(o)}`);for(const e of o);}else{for(const t in e.rooms)if(null!=Object.keys(e.rooms[t])){Object.keys(e.rooms[t].sockets).forEach(t=>{e.to(t).emit("serverMessage",{message:"hello friends!"})})}!0===this.consoleDisplay&&this.log(o)}break;case CHMessageType.LIST:for(const e of o)!0===this.consoleDisplay&&this.log(`emitting ${t} to ${e}`)}},h=()=>Array.from(this.Users.keys()),d=t=>{if(!this.verboseServerMessage)return;const o={message:t};e.emit("serverMessage",o)},c=t=>{if(null==t||"object"!=typeof t)return this.log(`addUsername payload is not an object: ${String(t)}`),void oe("addUsername payload must be an object.");const o=t;if(!Object.prototype.hasOwnProperty.call(o,"username"))return this.log("unable to change username - property missing"),oe("Unable to change username -- username property missing."),void d("Unable to change username -- username property missing");if("string"!=typeof o.username)return this.log("unable to change username - username must be a string, got: "+typeof o.username),void oe("Unable to change username -- username must be a string.");this.log("changing user name");const s=o.username.trim();if(0!==s.length){for(const[e,t]of this.Users.entries())if(t.username===s)return this.log("Username already exists. Username change rejected."),oe("Username already exists. Please select a different username."),void d("Username already exists. Please select a different username.");this.Users.has(e.id)||J(e),m("username",s),d(`Username updated: ${s}`),this.log("Updated username "+s+" for socket "+e.id),g(),F(),U(),j(),te()}else oe("Unable to change username -- username is empty/blank.")},g=o=>{if(void 0===o&&(o=e.id),this.Users.has(o)){const e={username:this.Users.get(o).username};this.IO.of(t).to(o).emit("myUsername",e)}else console.warn(`what username? for ${o}`)},m=(t,o)=>{if(this.Users.has(e.id)){const s=this.Users.get(e.id);s[t]=o,this.Users.set(e.id,s)}},u=(t,o)=>{if(this.Users.has(e.id)){const s=this.Users.get(e.id);if(["observingEvent","observingControl","myControls","myEvents"].includes(t)){if(s[t].includes(o))return void this.log(`Attempting to append non-appendable property in UserDetails: ${t} -- Already exists in property`);s[t].push(o),this.log(`---- Appended ${o} to ${t}`),this.Users.set(e.id,s)}else this.log(`Attempting to append non-appendable property in UserDetails: ${t}`)}},v=(t,o)=>{if(this.Users.has(e.id)){const s=this.Users.get(e.id);void 0!==s[t]&&(s[t]=s[t].filter(e=>e!==o)),this.Users.set(e.id,s)}},f=e=>{if(null==e||"object"!=typeof e)return this.log(`observeAllControl payload is not an object: ${String(e)}`),void d("observeAllControl payload must be an object.");const t=e;t.hasOwnProperty("observe")?("string"==typeof t.observe&&(t.observe=t.observe.toLowerCase(),t.observe="true"===t.observe),("number"==typeof t.observe&&1===t.observe||"string"==typeof t.observe&&"1"===t.observe)&&(t.observe=!0),("number"==typeof t.observe&&0===t.observe||"string"==typeof t.observe&&"0"===t.observe)&&(t.observe=!1),m("observeallcontrol",t.observe),this.log(`Observing all control ${t.observe} for ${N()}`)):this.log("observeAllControl missing 'observe' property")},p=e=>{if(null==e||"object"!=typeof e)return this.log(`observeAllEvents payload is not an object: ${String(e)}`),void d("observeAllEvents payload must be an object.");const t=e;t.hasOwnProperty("observe")?("string"==typeof t.observe&&(t.observe=t.observe.toLowerCase(),t.observe="true"===t.observe),("number"==typeof t.observe&&1===t.observe||"string"==typeof t.observe&&"1"===t.observe)&&(t.observe=!0),("number"==typeof t.observe&&0===t.observe||"string"==typeof t.observe&&"0"===t.observe)&&(t.observe=!1),m("observeallevents",t.observe),this.log(`Observing all events ${t.observe} for ${N()}`)):this.log("observeAllEvents missing 'observe' property")},b=(t,o)=>{if(null==t||"object"!=typeof t)return this.log(`observeControl payload is not an object: ${String(t)}`),d("observeControl payload must be an object."),void(null==o||o());const s=t;if(!Object.prototype.hasOwnProperty.call(s,"header"))return this.log(`${N()} attempting to observe control with no header.`),d("observeControl missing 'header' property."),void(null==o||o());const r=s.header;this.log(`${N()} observing : ${r}`);const n=this.Controls.filter(e=>e.header===r);n.length>0?n[0].observers.includes(e.id)?this.log(`${N()} already a subscriber to ${r}.`):(u("observingControl",r),n[0].observers.push(e.id),this.log(`Added control observer: ${N()} to ${n[0].header}`),U(),$(),R()):this.log(`Control header ${r} does not exist.`),null==o||o()},y=t=>{if(null==t||"object"!=typeof t)return console.warn("unobserveControl payload is not an object"),void d("unobserveControl payload must be an object.");const o=t;if(!Object.prototype.hasOwnProperty.call(o,"header"))return console.warn("unobserveControl missing header"),void d("unobserveControl missing 'header' property.");const s=o.header,r=this.Controls.find(e=>e.header===s);if(!r)return this.log(`Attempting to unobserve control with header: ${s}. Control does not exist`),void d(`Attempting to unobserve control with header: ${s}. Control does not exist`);Object.prototype.hasOwnProperty.call(r,"observers")?r.observers.includes(e.id)?(r.observers.splice(r.observers.indexOf(e.id),1),v("observingControl",s),r.observers||(r.observers=[]),this.log(`${N()} succcessfully unobserved from ${s}`),U(),$(),w(),R()):this.log("observer not found for unobserveControl"):this.log(`Attempting to unobserve header: ${s}. Header has no observers array.`)},C=(t,o)=>{if(null==t||"object"!=typeof t)return this.log(`observeEvent payload is not an object: ${String(t)}`),d("observeEvent payload must be an object."),void(null==o||o());const s=t;if(!Object.prototype.hasOwnProperty.call(s,"header"))return this.log("observeEvent request is missing header property"),d("observeEvent missing 'header' property."),void(null==o||o());const r=s.header;this.log(N()+" observing event "+r);const n=this.Events.filter(e=>e.header===r);n.length>0?n[0].observers.includes(e.id)?this.log(`${N()} already an observer of event ${r}.`):(u("observingEvent",r),n[0].observers.push(e.id),this.log("added event observer-- "+n[0].observers),j(),O(),I()):!0===this.consoleDisplay&&this.log(`Event header ${r} does not exist`),null==o||o()},O=o=>{void 0===o&&(o=e.id);const s=_.cloneDeep(this.Users);if(!s.has(o))return[];const r=_.cloneDeep(this.Events),n=s.get(o).myEvents,i=r.filter(e=>n.includes(e.header));for(const e in i)null!=i[e]&&(i[e].observers=i[e].observers.map(e=>N(e)),i[e].from=N(i[e].from));const a={events:i};return this.IO.of(t).to(o).emit("myEvents",a),i},$=o=>{void 0===o&&(o=e.id);const s=_.cloneDeep(this.Users);if(!s.has(o))return[];const r=_.cloneDeep(this.Controls),n=s.get(o).myControls,i=r.filter(e=>n.includes(e.header));for(const e in i)null!=i[e]&&(i[e].observers=i[e].observers.map(e=>N(e)),i[e].from=N(i[e].from));const a={controls:i};return this.IO.of(t).to(o).emit("myControls",a),i},E=(e,t)=>{if(null==e||"object"!=typeof e)return this.log(`unpublishControl payload is not an object: ${String(e)}`),void oe("unpublishControl payload must be an object.");const o=e;if(!Object.prototype.hasOwnProperty.call(o,"header"))return this.log("unpublishControl is missing header key."),oe("unpublishControl is missing header key."),void d("unpublishControl is missing header key.");this.Controls.map(e=>e.header).includes(o.header)?(this.Controls=this.Controls.filter(e=>e.header!==o.header),this.log(`Unpublished Control with header: ${o.header}.`)):this.log("Attempting to unpublish a non-existent header."),null==t||t()},U=()=>{const e=_.cloneDeep(this.Controls);for(const t in e)null!=e[t]&&(e[t].observers=e[t].observers.map(e=>N(e)),e[t].from=N(e[t].from));const o={controls:e};return this.IO.of(t).emit("allControls",o),e},j=()=>{const e=_.cloneDeep(this.Events);for(const t in e)null!=e[t]&&(e[t].observers=e[t].observers.map(e=>N(e)),e[t].from=N(e[t].from));const o={events:e};return this.IO.of(t).emit("allEvents",o),e},w=o=>{this.log("listing observed controls"),void 0===o&&(o=e.id);const s=_.cloneDeep(this.Controls).filter(e=>e.observers.includes(o));for(const e in s)null!=s[e]&&(s[e].observers=s[e].observers.map(e=>N(e)),s[e].from=N(s[e].from));const r={controls:s};return this.log("observed Controls: "+s),this.IO.of(t).to(o).emit("observedControls",r),s},A=o=>{this.log("listing observed events"),void 0===o&&(o=e.id);const s=_.cloneDeep(this.Events).filter(e=>e.observers.includes(o));for(const e in s)null!=s[e]&&(s[e].observers=s[e].observers.map(e=>N(e)),s[e].from=N(s[e].from));const r={events:s};return this.log("observed Events: "+s),this.IO.of(t).to(o).emit("observedEvents",r),s},H=(e,t)=>{if(null==e||"object"!=typeof e)return this.log(`unpublishEvent payload is not an object: ${String(e)}`),void oe("unpublishEvent payload must be an object.");const o=e;if(!Object.prototype.hasOwnProperty.call(o,"header"))return this.log("unpublishEvent is missing header key."),oe("unpublishEvent is missing header key."),void d("unpublishEvent is missing header key.");this.Events.map(e=>e.header).includes(o.header)?(this.Events=this.Events.filter(e=>e.header!==o.header),this.log(`Unpublished Event with header: ${o.header}.`)):this.log("Attempting to unpublish event with non-existent header."),null==t||t()},R=o=>{null==o&&(o=e.id);const s=this.Users.get(o);if(!s)return this.log(`availableControls: unknown socket id ${o}`),[];const r=_.cloneDeep(this.Controls),n=r.filter(e=>"all"===e.target),i=r.filter(e=>e.target===N(o)),a=D(o),l=r.filter(e=>a.includes(e.target));let h=n.concat(l);h=h.concat(i),h=[...new Set(h)].sort();const d=$(o).map(e=>e.header);h=h.filter(e=>!d.includes(e.header));const c=s.observingControl;c.length>0&&(h=h.filter(e=>!c.includes(e.header)));for(const e in h)null!=h[e]&&(h[e].observers=h[e].observers.map(e=>N(e)),h[e].from=N(h[e].from));const g={controls:h.filter(e=>e.header)};this.IO.of(t).to(o).emit("availableControlsList",g);const m={controls:h};return this.IO.of(t).to(o).emit("availableControls",m),h},M=()=>{this.Users.forEach(e=>{R(e.id),w(e.id)})},S=()=>{this.Users.forEach(e=>{I(e.id),A(e.id)})},I=o=>{null==o&&(o=e.id);const s=this.Users.get(o);if(!s)return this.log(`availableEvents: unknown socket id ${o}`),[];const r=_.cloneDeep(this.Events),n=r.filter(e=>"all"===e.target),i=r.filter(e=>e.target===N(o)),a=D(o),l=r.filter(e=>a.includes(e.target));let h=n.concat(l);h=h.concat(i),h=[...new Set(h)].sort();const d=O(o).map(e=>e.header);h=h.filter(e=>!d.includes(e.header));const c={events:n.filter(e=>e.header)};this.IO.of(t).to(o).emit("availableEventsList",c);const g=s.observingEvent;g.length>0&&(h=h.filter(e=>!g.includes(e.header)));for(const e in h)null!=h[e]&&(h[e].observers=h[e].observers.map(e=>N(e)),h[e].from=N(h[e].from));const m={events:h};return this.IO.of(t).to(o).emit("availableEvents",m),h},k=t=>{if(null==t||"object"!=typeof t)return this.log(`unobserveEvent payload is not an object: ${String(t)}`),void d("unobserveEvent payload must be an object.");const o=t;if(!Object.prototype.hasOwnProperty.call(o,"header"))return this.log("unobserveEvent is missing header parameter."),void d("unobserveEvent is missing header parameter.");if(""===o.header)return this.log("Unobserve has empty header"),void d("unobserveEvent header is empty/blank.");const s=this.Events.filter(e=>e.header===o.header);if(!s||!s[0])return void this.log(`Event ${o.header} not found.`);const r=s[0];Object.prototype.hasOwnProperty.call(r,"observers")?r.observers.includes(e.id)?(r.observers.splice(r.observers.indexOf(e.id),1),v("observingEvent",o.header),this.log("removing observer "+N()+" from event"),r.observers||(r.observers=[]),j(),O(),A(),I()):this.log("event observer not found"):this.log("no observers property on event "+o.header)},T=t=>{Array.isArray(t.header)?this.Events=this.Events.filter(e=>!t.header.includes(e.header)):this.Events=null!==t||void 0!==t?this.Events.filter(e=>e.header!==t.header):this.Events.filter(t=>t.from!==e.id)},P=e=>{for(const[t,o]of this.Users.entries())if(o.username===e)return o.id;return null},D=e=>{if(this.IO.of(t).adapter.sids.has(e)){let o=Array.from(this.IO.of(t).adapter.sids.get(e));return o=o.filter(t=>t!==e),o}return this.log(`Adapter.sids error for ${e}`),[]},N=t=>(null==t&&(t=e.id),this.Users.has(t)?void 0===this.Users.get(t)||null===this.Users.get(t)?(this.log(`User name for ${this.Users.get(t)} is undefined -- ${t}`),null):this.Users.get(t).username:(this.log("SERIOUS ERROR!! --- unable to find username for connect id "+t),console.dir(this.Users),null)),L=()=>(this.Users.clear(),this),x=t=>{Array.isArray(t.header)?this.Controls=this.Controls.filter(e=>!t.header.includes(e.header)):this.Controls=null!==t||void 0!==t?this.Controls.filter(e=>e.header!==t.header):this.Controls.filter(t=>t.from!==e.id)},V=()=>"User"+Math.floor(Math.random()*this.Users.size*10).toString().padStart(3,"0"),q=()=>{let e=V();for(const[t,o]of this.Users.entries())if(o.username===e){this.log("Username already exists"),e=q();break}return e},J=e=>{if(this.log(t+": -------- Adding user "),!this.Users.has(e.id)){let t=q();e.handshake.query.username&&(this.log("replacing username with "+e.handshake.query.username),t=e.handshake.query.username);const o={username:t,id:e.id,myControls:[],myEvents:[],observingEvent:[],observingControl:[],observeallcontrol:!1,observeallevents:!1};this.Users.set(e.id,o)}F()},B=()=>{this.log(`A user disconnected: ${e.id} - ${N(e.id)}`);const t=this.Controls.filter(t=>t.from===e.id).map(e=>e.header),o=this.Events.filter(t=>t.from===e.id).map(e=>e.header);for(const[e,s]of this.Users.entries())this.Users.has(e)&&(this.Users.get(e).observingControl=this.Users.get(e).observingControl.filter(e=>!t.includes(e)),this.Users.get(e).observingEvent=this.Users.get(e).observingEvent.filter(e=>!o.includes(e)));this.Users.delete(e.id),this.Controls=this.Controls.filter(t=>t.from!==e.id),this.Events=this.Events.filter(t=>t.from!==e.id),F(),j(),U(),Q(),M(),S()},F=()=>{const e=this.Users,o={users:e},s=h().map(e=>N(e)),r={users:s};this.log("All users: "+s),console.dir(s),this.IO.of(t).emit("allUserDetails",o),this.IO.of(t).emit("allUsers",r),h().forEach(o=>{const s={users:h().filter(e=>e!==o).map(e=>N(e))},r=new Map(e);r.delete(o);const n={users:r};this.IO.of(t).to(o).emit("otherUsers",s),this.IO.of(t).to(o).emit("otherUserDetails",n)})},G=e=>{"string"==typeof e||"boolean"==typeof e?(this.consoleDisplay=this.boolHandler(e),this.log(`changed console display to ${this.consoleDisplay}`)):(this.log(`setConsoleDisplay received non-boolean value: ${JSON.stringify(e)}`),oe("setConsoleDisplay value must be boolean or 'true'/'false'."))},K=e=>{for(const t of this.Controls)if(this.log(t.header),t.header===e)return t;return this.log("No such control values: "+e),null},Y=e=>e||void 0===e?Array.from(this.IO.of(t).adapter.rooms.keys()).filter(e=>!h().includes(e)):Array.from(this.IO.of(t).adapter.rooms.keys()),z=e=>{const o=new Map(this.IO.of(t).adapter.rooms),s=Object.fromEntries(o),r={};for(const t in s)if(Object.prototype.hasOwnProperty.call(s,t))if(e||void 0===e){if(h().includes(t))continue;{const e=Array.from(s[t]);r[t]=e}}else{const e=Array.from(s[t]);r[t]=e}return r},Q=()=>{const e={rooms:Y(!0)},o={rooms:z()};this.IO.of(t).emit("allRooms",e),this.IO.of(t).emit("allRoomDetails",o)},W=o=>{null==o&&(o=e.id);const s=this.IO.of(t).adapter.sids.get(o);if(!s){this.log(`myRooms: adapter.sids has no entry for ${o}`);const e={rooms:{}};return void this.IO.of(t).to(o).emit("myRooms",e)}const r=new Set(s);let n=Array.from(r);n=n.filter(e=>e!==o);const i=new Map(this.IO.of(t).adapter.rooms),a={};n.forEach(e=>{const t=i.get(e);t&&(a[e]=Array.from(t).map(e=>N(e)))});const l={rooms:a};this.IO.of(t).to(o).emit("myRooms",l)},X=o=>{null==o&&(o=e.id);const s=this.IO.of(t).adapter.sids.get(o);if(!s){this.log(`myRoomsList: adapter.sids has no entry for ${o}`);const e={rooms:[]};return this.IO.of(t).to(o).emit("myRoomsList",e),[]}const r=new Set(s);let n=Array.from(r);n=n.filter(e=>e!==o);const i={rooms:n};return this.IO.of(t).to(o).emit("myRoomsList",i),n},Z=o=>{void 0===o&&(o=e.id);const s=new Map(this.IO.of(t).adapter.rooms),r=Array.from(this.Users.keys()).concat(X(o)||[]),n={};for(const e of s.keys())if(!r.includes(e)){const t=s.get(e);if(!t)continue;let o=Array.from(t);o=o.map(e=>N(e)),n[e]=o}const i={rooms:n};this.IO.of(t).to(o).emit("availableRooms",i)},ee=o=>{void 0===o&&(o=e.id);const s=new Map(this.IO.of(t).adapter.rooms),r=Array.from(s.keys()).filter(e=>!Array.from(this.Users.keys()).includes(e)),n=X(o)||[],i={rooms:r.filter(e=>!n.includes(e))};this.IO.of(t).to(o).emit("availableRoomsList",i)},te=()=>{Q(),this.Users.forEach(e=>{W(e.id),X(e.id),Z(e.id),ee(e.id)})},oe=(o,s)=>{const r={message:o};s?this.IO.of(t).to(s).emit(CHMessageType.ERROR,r):e.emit(CHMessageType.ERROR,r)};e.on("chPing",t=>{e.emit("chPingBack",t)}),(()=>{e.emit("connected","connected"),e.emit("connection","connected"),d("Collab-Hub Version: "+this.Version+". You're in Namespace "+t),J(e),te(),j(),I(),U(),R(),g()})()}enumKeys(e){return Object.keys(e).filter(e=>Number.isNaN(+e))}isCHControlToServer(e){return"target"in e}}exports.default=HUB;